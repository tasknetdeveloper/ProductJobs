Описание проектов:

OrderApi - web api для выполнения запросов, которые приходят в виде pipeline  (
2 варианта - последовательное выполнение, выполнение по цепочке в зависимости от 
статуса выполнения предыдущего шага)

Предполагается, что сервис будет горизонтально масштабирован, задачи
сервис получает от балансировщика нагрузки, который имея в своем арсенале массие
endpoint всех сервисов по кругу отправляет им задания, таким образом достигается конкурентная работа


Замечание:

реализация
"
1.	брать новые заказы, те, что только что были добавлены (вариант: в определённом статусе пусть у нас есть такое поле или с пустым каким-то флагом)
2.	выполнить с заказом какую-то не быструю операцию (до минуты – можно для симуляции работы просто встать в рандомную задержку)
3.	в зависимости от результата предыдущего шага (возвращать рандомно) либо проставить новый статус (или заполнить флаг), либо вернуть начальный из шага 1
"
осуществляется методами контроллера RequestWithRulesPipeline и RequestWithPipeline

непосредственная реализация каждого шага в данной версии нереализована, поскольку требует
большего времени, это частности и здесь можно реализовать любое количество типов обработки
запросов в зависимости от OrderOperationType
и вытекающих из статуса выполнения  NextOperationWhenSuccessResponse и NextOperationWhenErrorResponse
которые определят следующий шаг в случае с использованием метода RequestWithRulesPipeline
(Данная реализация цепочки - это упрощенная версия, взаимосвязь шагов можно усложнить..) и 
последовательное выполнение шагов (запросов в массиве) в случае выполнения метода RequestWithPipeline.



что можно сделать по пункту 1. :
новые заказы размещать одновременно в базе данных и в кэш и одновременно установить 
флаг равный уникальному порядковому номеру инстанса сервиса, который взял заказ в обработку,
а после отработки запроса инстанс джоба удаляет запись из кэш.
таким образом будет достигнуто обеспечение изоляции записи заказа в кэш для конкретного
инстанса джоба.

для изоляции в моделях Product, OrderItem
существуют свойства:

        [Indexed(Sortable = true)]
        public OperationStatus Status { get; } = OperationStatus.Empty;
        public int InstanceNumber { get; set; } = -1;


что можно сделать по пункту 3 :
аналогичным образом производить обработку заказа в кэш, используя поля Status, InstanceNumber 


ReadEmulator - консольное приложение, которое запускается отдельно, оно эмулируем чтение
				данных 

InsertEmulator - консольное приложение, которое запускается отдельно, оно эмулируем запись
				информации в базу данных

RedisWorkOM - проект, который обеспечивает работу с кэш Redis (таблицы Product, OrderItem
			  образуют 2 отдельные очереди), работа с Redis обеспечит быстрое чтение 
			  данных, снимет нагрузку с БД



Все запускаемые проекты имеют файл настройки appsettings
соотв-но в них можно указать все необходимые таймауты

